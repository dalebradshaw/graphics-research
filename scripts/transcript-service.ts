/**
 * Transcript Service - Robust transcript extraction with fallbacks, caching, and retry logic
 */
import { promises as fs } from "fs";
import * as path from "path";
import { YoutubeTranscript } from "youtube-transcript";
import { TranscriptCache } from "./transcript-caching.js";

export interface TranscriptServiceConfig {
  maxRetries?: number;
  baseDelayMs?: number;
  maxDelayMs?: number;
  timeoutMs?: number;
  cacheEnabled?: boolean;
  cacheDir?: string;
  defaultLanguages?: string[];
  userAgent?: string;
}

export interface TranscriptResult {
  videoId: string;
  transcript: string;
  language: string;
  isAutoGenerated: boolean;
  duration: number;
  segments: TranscriptSegment[];
  cached: boolean;
  fetchDurationMs: number;
}

export interface TranscriptSegment {
  text: string;
  offset: number;
  duration: number;
}

export interface TranscriptError {
  videoId: string;
  error: string;
  errorType: TranscriptErrorType;
  retryable: boolean;
}

export type TranscriptErrorType =
  | "RATE_LIMIT"
  | "IP_BLOCKED"
  | "VIDEO_UNAVAILABLE"
  | "TRANSCRIPT_DISABLED"
  | "LANGUAGE_NOT_AVAILABLE"
  | "NETWORK_ERROR"
  | "TIMEOUT"
  | "UNKNOWN";

const DEFAULT_CONFIG: Required<TranscriptServiceConfig> = {
  maxRetries: 3,
  baseDelayMs: 1000,
  maxDelayMs: 30000,
  timeoutMs: 30000,
  cacheEnabled: true,
  cacheDir: ".transcript-cache",
  defaultLanguages: ["en"],
  userAgent:
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15"
};

export class TranscriptService {
  private config: Required<TranscriptServiceConfig>;
  private cache: TranscriptCache;
  private requestQueue: Map<string, Promise<TranscriptResult | TranscriptError>> = new Map();

  constructor(config: TranscriptServiceConfig = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.cache = new TranscriptCache(this.config.cacheDir);
  }

  /**
   * Initialize the service (creates cache directory)
   */
  async initialize(): Promise<void> {
    if (this.config.cacheEnabled) {
      await this.cache.initialize();
    }
  }

  /**
   * Extract video ID from various YouTube URL formats
   */
  static extractVideoId(url: string): string | null {
    const patterns = [
      /[?&]v=([^&#]+)/,
      /youtu\.be\/([^?&#]+)/,
      /youtube\.com\/embed\/([^?&#]+)/,
      /youtube\.com\/v\/([^?&#]+)/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }

    return null;
  }

  /**
   * Fetch transcript with caching and retry logic
   */
  async fetchTranscript(
    videoIdOrUrl: string,
    options: {
      languages?: string[];
      forceRefresh?: boolean;
    } = {}
  ): Promise<TranscriptResult | TranscriptError> {
    const videoId = TranscriptService.extractVideoId(videoIdOrUrl) || videoIdOrUrl;
    const languages = options.languages || this.config.defaultLanguages;

    if (this.requestQueue.has(videoId)) {
      return this.requestQueue.get(videoId)!;
    }

    const promise = this._fetchTranscriptInternal(videoId, languages, options.forceRefresh);
    this.requestQueue.set(videoId, promise);

    try {
      const result = await promise;
      return result;
    } finally {
      this.requestQueue.delete(videoId);
    }
  }

  private async _fetchTranscriptInternal(
    videoId: string,
    languages: string[],
    forceRefresh?: boolean
  ): Promise<TranscriptResult | TranscriptError> {
    const startTime = Date.now();

    if (!forceRefresh && this.config.cacheEnabled) {
      const cached = await this.cache.get<Omit<TranscriptResult, "cached" | "fetchDurationMs">>(videoId);
      if (cached) {
        return {
          ...cached,
          cached: true,
          fetchDurationMs: Date.now() - startTime
        };
      }
    }

    for (let attempt = 0; attempt < this.config.maxRetries; attempt++) {
      try {
        const result = await this._fetchWithTimeout(videoId, languages);

        if (this.config.cacheEnabled) {
          await this.cache.set(videoId, { ...result, cached: false, fetchDurationMs: 0 });
        }

        return {
          ...result,
          cached: false,
          fetchDurationMs: Date.now() - startTime
        };
      } catch (error) {
        const errorType = this._classifyError(error);
        const retryable = this._isRetryableError(errorType);

        if (!retryable || attempt === this.config.maxRetries - 1) {
          return {
            videoId,
            error: error instanceof Error ? error.message : String(error),
            errorType,
            retryable
          };
        }

        const delay = this._calculateBackoff(attempt);
        await this._sleep(delay);
      }
    }

    return {
      videoId,
      error: "Max retries exceeded",
      errorType: "UNKNOWN",
      retryable: false
    };
  }

  private async _fetchWithTimeout(
    videoId: string,
    languages: string[]
  ): Promise<Omit<TranscriptResult, "cached" | "fetchDurationMs">> {
    return Promise.race([
      this._fetchTranscriptData(videoId, languages),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error("Request timeout")), this.config.timeoutMs)
      )
    ]);
  }

  private async _fetchTranscriptData(
    videoId: string,
    languages: string[]
  ): Promise<Omit<TranscriptResult, "cached" | "fetchDurationMs">> {
    let lastError: Error | null = null;

    for (const lang of languages) {
      try {
        const segments = await YoutubeTranscript.fetchTranscript(videoId, {
          lang
        });

        if (segments && segments.length > 0) {
          const transcript = segments.map((s) => s.text).join(" ").replace(/\s+/g, " ").trim();
          const duration = segments[segments.length - 1]!.offset + (segments[segments.length - 1]!.duration || 0);

          return {
            videoId,
            transcript,
            language: lang,
            isAutoGenerated: false,
            duration,
            segments: segments.map((s) => ({
              text: s.text,
              offset: s.offset,
              duration: s.duration || 0
            }))
          };
        }
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        if (error instanceof Error && error.message.includes("Transcript is disabled")) {
          throw error;
        }
      }
    }

    throw lastError || new Error("No transcript available for any language");
  }

  private _classifyError(error: unknown): TranscriptErrorType {
    if (!(error instanceof Error)) return "UNKNOWN";

    const message = error.message.toLowerCase();

    if (message.includes("429") || message.includes("rate limit")) {
      return "RATE_LIMIT";
    }
    if (message.includes("403") || message.includes("forbidden") || message.includes("ip block")) {
      return "IP_BLOCKED";
    }
    if (message.includes("unavailable") || message.includes("private") || message.includes("deleted")) {
      return "VIDEO_UNAVAILABLE";
    }
    if (message.includes("disabled") || message.includes("no transcript")) {
      return "TRANSCRIPT_DISABLED";
    }
    if (message.includes("language") || message.includes("not available")) {
      return "LANGUAGE_NOT_AVAILABLE";
    }
    if (message.includes("timeout")) {
      return "TIMEOUT";
    }
    if (message.includes("network") || message.includes("fetch")) {
      return "NETWORK_ERROR";
    }

    return "UNKNOWN";
  }

  private _isRetryableError(errorType: TranscriptErrorType): boolean {
    return ["RATE_LIMIT", "IP_BLOCKED", "NETWORK_ERROR", "TIMEOUT", "UNKNOWN"].includes(errorType);
  }

  private _calculateBackoff(attempt: number): number {
    const exponentialDelay = this.config.baseDelayMs * Math.pow(2, attempt);
    const jitter = Math.random() * 1000;
    return Math.min(exponentialDelay + jitter, this.config.maxDelayMs);
  }

  private _sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Fetch multiple transcripts with rate limiting
   */
  async fetchBatch(
    videoIds: string[],
    options: {
      languages?: string[];
      concurrency?: number;
      onProgress?: (completed: number, total: number) => void;
      delayBetweenRequests?: number;
    } = {}
  ): Promise<(TranscriptResult | TranscriptError)[]> {
    const { concurrency = 3, onProgress, delayBetweenRequests = 1000 } = options;
    const results: (TranscriptResult | TranscriptError)[] = [];

    for (let i = 0; i < videoIds.length; i += concurrency) {
      const batch = videoIds.slice(i, i + concurrency);
      const batchPromises = batch.map((id) => this.fetchTranscript(id, { languages: options.languages }));

      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);

      if (onProgress) {
        onProgress(Math.min(i + batch.length, videoIds.length), videoIds.length);
      }

      if (i + concurrency < videoIds.length && delayBetweenRequests > 0) {
        await this._sleep(delayBetweenRequests);
      }
    }

    return results;
  }

  /**
   * Clear the cache
   */
  async clearCache(): Promise<void> {
    await this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  async getCacheStats(): Promise<{
    totalEntries: number;
    totalSizeBytes: number;
    oldestEntry: Date | null;
    newestEntry: Date | null;
  }> {
    return this.cache.getStats();
  }
}

export default TranscriptService;
